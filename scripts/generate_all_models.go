package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"strings"
)

func main() {

	// Define paths
	modelsFolderPath := "../models"
	allModelsFilePath := modelsFolderPath + "/all_models.go"

	// Step 1: Parse the models package and get model names
	modelNames, err := getModelNames(modelsFolderPath)
	if err != nil {
		log.Fatalf("Failed to get model names: %v", err)
	}

	// Step 2: Read and update the all_models.go file
	err = updateAllModelsFile(allModelsFilePath, modelNames)
	if err != nil {
		log.Fatalf("Failed to update all_models.go: %v", err)
	}
}

// getModelNames parses the models package and returns a slice of model struct names
func getModelNames(modelsFolderPath string) ([]string, error) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, modelsFolderPath, nil, 0)
	if err != nil {
		return nil, err
	}

	pkg, ok := pkgs["models"]
	if !ok {
		return nil, fmt.Errorf("package 'models' not found: %v", pkgs)
	}

	var modelStructNames []string
	for _, file := range pkg.Files {
		// Iterate over all declarations in the file
		for _, decl := range file.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}
			// Iterate over all type specifications
			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				// Check if the type is a struct
				if _, ok := typeSpec.Type.(*ast.StructType); ok {
					modelStructNames = append(modelStructNames, typeSpec.Name.Name)
				}
			}
		}
	}

	return modelStructNames, nil
}

// updateAllModelsFile reads the existing all_models.go file, removes the old AllModels slice,
// and writes the new AllModels slice with the updated model names
func updateAllModelsFile(filePath string, modelNames []string) error {
	// Read the existing all_models.go file
	contentBytes, err := os.ReadFile(filePath)
	if err != nil {
		return err
	}
	content := string(contentBytes)

	// Find the index where "var AllModels =" starts
	splitMarker := "var AllModels ="
	idx := strings.Index(content, splitMarker)

	if idx != -1 {
		// Remove everything from "var AllModels =" onwards
		content = content[:idx]
	} else {
		// Ensure we have a newline before appending
		if !strings.HasSuffix(content, "\n") {
			content += "\n"
		}
	}

	// Generate the new AllModels code
	allModelsCode := generateAllModelsCode(modelNames)

	// Combine the content and the generated code
	newContent := content + allModelsCode

	// Format the combined code
	formattedContent, err := format.Source([]byte(newContent))
	if err != nil {
		return err
	}

	// Write the updated content back to all_models.go
	err = os.WriteFile(filePath, formattedContent, fs.FileMode(0644))
	if err != nil {
		return err
	}

	return nil
}

// generateAllModelsCode generates the code for the AllModels slice
func generateAllModelsCode(modelNames []string) string {
	var sb strings.Builder
	sb.WriteString("\n\n// AllModels is a list of all models to be migrated.\n")
	sb.WriteString("// Code generated by generate_all_models.go; DO NOT EDIT.\n")
	sb.WriteString("var AllModels = []interface{}{\n")
	for _, modelName := range modelNames {
		sb.WriteString("\t&" + modelName + "{},\n")
	}
	sb.WriteString("}\n")
	return sb.String()
}
